# Синхронизированный доступ к списку

## Описание проекта

Программа реализует синхронизированный доступ к списку строк с многопоточной сортировкой алгоритмом пузырька.

## Структура проекта

- `CustomLinkedList.java` - собственная реализация двусвязного списка с поддержкой Iterable
- `SortingThread.java` - поток сортировки для CustomLinkedList
- `Main.java` - главный класс программы с собственной реализацией списка
- `ArrayListSortingThread.java` - поток сортировки для ArrayList
- `MainArrayList.java` - главный класс программы с ArrayList и Collections.synchronizedList()
- `StepMeasurementTest.java` - тестовая программа для измерения количества шагов

## Компиляция и запуск

### Компиляция

```bash
cd task_2
javac -d target/classes src/main/java/com/task2/*.java
```

Или с использованием Maven:

```bash
mvn compile
```

### Запуск программы с собственной реализацией списка

```bash
java -cp target/classes com.task2.Main
```

### Запуск программы с ArrayList

```bash
java -cp target/classes com.task2.MainArrayList
```

### Запуск теста измерения шагов

```bash
java -cp target/classes com.task2.StepMeasurementTest
```

## Использование

1. Программа запускается и ожидает ввода строк
2. Введите строки для добавления в список (они будут добавлены в начало)
3. Строки длиннее 80 символов автоматически разрезаются на несколько строк
4. Введите пустую строку для вывода текущего состояния списка
5. Введите `exit` для завершения программы

## Особенности реализации

### Собственная реализация списка (CustomLinkedList)

- Двусвязный список с узлами, содержащими строки
- Реализует интерфейс `Iterable<String>`
- Переустановка ссылок при перестановке узлов (не обмен содержимым)
- Синхронизация на уровне отдельных узлов для предотвращения блокировки всего списка
- Захват блокировок в порядке от головы к хвосту для предотвращения deadlock

### Реализация с ArrayList

- Использует `Collections.synchronizedList()` для синхронизации
- Алгоритм сортировки адаптирован для работы с индексами вместо узлов
- Использует `Collections.swap()` для обмена элементов

## Алгоритм сортировки

Обе реализации используют бесконечный вариант алгоритма пузырька:
- Поток проходит весь список от начала до конца
- Сравнивает соседние элементы лексикографически
- Если элементы в неправильном порядке, меняет их местами
- После перестановки начинает новый проход с начала
- Между шагами и внутри шагов есть регулируемая задержка (по умолчанию 1 секунда)

## Теоретический расчет количества шагов

### Собственная реализация списка

**Теоретически максимальное количество шагов:**

При работе N потоков в течение времени T с задержкой D:
- Каждый шаг включает задержку внутри шага (D) и между шагами (D) = 2D
- Максимальное количество шагов на один поток: T / (2D)
- С учетом параллельной работы N потоков: N × (T / (2D))

**Особенности:**
- Потоки работают независимо и могут одновременно обрабатывать разные части списка
- Из-за мелкозернистой блокировки (на уровне узлов) потоки меньше блокируют друг друга
- После каждой перестановки поток начинает новый проход с начала, что может увеличить количество шагов

### Реализация с ArrayList

**Теоретически максимальное количество шагов:**

Аналогично собственной реализации:
- N × (T / (2D))

**Особенности:**
- Блокировка происходит на весь список (`synchronized (list)`)
- Потоки больше блокируют друг друга, что может уменьшить эффективность параллельной работы
- Но из-за более простой структуры данных операции могут выполняться быстрее

## Фактические результаты

При тестировании с параметрами:
- Количество потоков: 2
- Время теста: 5 секунд
- Задержка: 100 мс

**Ожидаемые различия:**

1. **Собственная реализация:**
   - Меньше блокировок между потоками (блокировка на уровне узлов)
   - Больше параллелизма
   - Больше шагов из-за возможности параллельной работы

2. **ArrayList реализация:**
   - Больше блокировок (блокировка всего списка)
   - Меньше параллелизма
   - Меньше шагов из-за последовательной обработки

**Важные факторы:**

- Конкуренция потоков: при собственной реализации потоки могут работать параллельно над разными частями списка
- Блокировки: ArrayList блокирует весь список, что уменьшает параллелизм
- Контекстное переключение: больше параллелизма может привести к большему количеству переключений контекста

## Выводы

1. **Собственная реализация** позволяет достичь большего параллелизма благодаря мелкозернистой блокировке, что теоретически должно привести к большему количеству шагов за то же время.

2. **ArrayList реализация** имеет более грубую блокировку, что уменьшает параллелизм, но может быть более предсказуемой по поведению.

3. Фактическое количество шагов зависит от многих факторов: конкуренции потоков, планировщика потоков JVM, нагрузки системы и т.д.

4. Для точного сравнения необходимо провести множественные запуски и усреднить результаты.

