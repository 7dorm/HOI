# Асинхронный обход ресурсов HTTP-сервера

## Описание проекта

Программа реализует "паука" (web crawler) для асинхронного обхода ресурсов HTTP-сервера. Программа использует виртуальные потоки Java 21 для параллельной обработки запросов и собирает все сообщения с сервера, начиная с корневого пути "/".

## Требования

- Java 21 или выше (для поддержки виртуальных потоков)
- Maven 3.6+ (для сборки проекта)
- Запущенный HTTP-сервер (Task_J3-server.jar)

## Структура проекта

- `ServerResponse.java` - класс для представления ответа сервера (JSON структура)
- `HttpClient.java` - класс для выполнения HTTP запросов и парсинга JSON
- `WebCrawler.java` - основной класс crawler'а с использованием виртуальных потоков
- `Main.java` - главный класс программы

## Компиляция и сборка

### Сборка JAR файла с помощью Maven

```bash
cd task_3
mvn clean package
```

После успешной сборки будет создан файл `target/Task_J3-client.jar`

### Компиляция без Maven

```bash
javac -d target/classes -cp "lib/*" src/main/java/com/task3/*.java
```

## Запуск сервера

Перед запуском клиента необходимо запустить сервер:

```bash
java -jar Task_J3-server.jar <student_id> [port]
```

Примеры:
```bash
# student_id = IvanIvanov, порт по умолчанию 8080
java -jar Task_J3-server.jar IvanIvanov

# student_id = PetrPetrov, порт 3000
java -jar Task_J3-server.jar PetrPetrov 3000
```

## Запуск клиента

### После сборки Maven

```bash
java -jar target/Task_J3-client.jar <student_id> [host] [port]
```

Примеры:
```bash
# Использование параметров по умолчанию (localhost:8080)
java -jar target/Task_J3-client.jar IvanIvanov

# Указание хоста и порта
java -jar target/Task_J3-client.jar IvanIvanov localhost 8080
```

### Параметры запуска

1. `student_id` (обязательный) - имя и фамилия студента латиницей
2. `host` (опциональный) - хост сервера, по умолчанию `localhost`
3. `port` (опциональный) - порт сервера, по умолчанию `8080`

## Особенности реализации

### Виртуальные потоки (Java 21)

Программа использует виртуальные потоки (`Executors.newVirtualThreadPerTaskExecutor()`) для параллельной обработки HTTP запросов. Виртуальные потоки позволяют создавать миллионы легковесных потоков без значительных накладных расходов на память.

### Асинхронный обход

- Программа начинает обход с корневого пути "/"
- Для каждого пути выполняется HTTP GET запрос
- Полученный JSON парсится, извлекается сообщение и список successors
- Все successors обходятся параллельно с использованием виртуальных потоков
- Используется `Phaser` для синхронизации завершения всех задач

### Предотвращение повторных посещений

Используется `ConcurrentHashMap.newKeySet()` для отслеживания уже посещенных путей, что предотвращает бесконечные циклы и повторную обработку одних и тех же ресурсов.

### Сортировка результатов

Все собранные сообщения сортируются в лексикографическом порядке перед выводом.

## Формат ответа сервера

Сервер возвращает JSON в следующем формате:

```json
{
  "message": "some text",
  "successors": ["path_1", "path_2", "path_3", ..., "path_n"]
}
```

где:
- `message` - текстовое сообщение
- `successors` - массив путей для дальнейшего обхода

## Пример вывода

```
Запуск обхода сервера:
  Host: localhost
  Port: 8080
  Student ID: IvanIvanov

Обход завершен за 45230 мс
Найдено сообщений: 150

Результат (отсортированный в лексикографическом порядке):
================================================================================
Message 1
Message 2
...
Message 150
================================================================================
```

## Производительность

- Сервер может обрабатывать запрос от 0 до 12 секунд
- Вся информация может быть собрана минимум за 120 секунд
- Использование виртуальных потоков позволяет эффективно обрабатывать множество параллельных запросов

## Обработка ошибок

- Программа обрабатывает ошибки HTTP запросов и продолжает работу
- Ошибки выводятся в stderr, но не прерывают обход других путей
- Таймаут подключения установлен в 30 секунд

## Зависимости

- Jackson Databind 2.15.2 - для парсинга JSON
- Java 21 - для поддержки виртуальных потоков

