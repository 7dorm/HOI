# Task C1: Генерация строк без повторяющихся подряд символов

## Описание

Реализация функции на Clojure, которая генерирует все возможные строки заданной длины из алфавита, не содержащие одинаковых подряд идущих символов.

## Требования

- Clojure 1.11+
- Leiningen (для сборки и тестирования)

## Структура проекта

```
task-c1/
├── src/
│   └── task_c1/
│       └── core.clj          # Основная реализация
├── test/
│   └── task_c1/
│       └── core_test.clj     # Тесты
├── project.clj               # Конфигурация Leiningen
└── README.md                  # Документация
```

## Функция `generate-strings`

### Сигнатура

```clojure
(generate-strings alphabet n)
```

### Параметры

- `alphabet` - список однобуквенных строк (алфавит)
- `n` - длина результирующих строк

### Возвращаемое значение

Список строк длины `n`, составленных из символов алфавита, не содержащих одинаковых подряд идущих символов.

### Примеры использования

```clojure
;; Пример 1: алфавит ("a" "b" "c"), N=2
(generate-strings ["a" "b" "c"] 2)
;; => ("ab" "ac" "ba" "bc" "ca" "cb")

;; Пример 2: алфавит ("a" "b" "c"), N=3
(generate-strings ["a" "b" "c"] 3)
;; => ("aba" "abc" "aca" "acb" "bab" "bac" "bca" "bcb" "cab" "cac" "cba" "cbc")

;; Пример 3: алфавит из 2 символов ("x" "y"), N=4
(generate-strings ["x" "y"] 4)
;; => ("xyxy" "yxyx")
```

## Алгоритм

Функция использует итеративный подход с `reduce`:

1. **Начальное состояние**: все символы алфавита (строки длины 1)
2. **Итеративное построение**: на каждом шаге для каждой текущей строки:
   - Определяется последний символ строки
   - Из алфавита удаляются символы, совпадающие с последним
   - К каждой строке добавляется каждый доступный символ
3. **Повторение**: процесс повторяется (n-1) раз для получения строк длины n

### Используемые операции

- `map` - для преобразования списков
- `reduce` - для итеративного построения результата
- `filter` / `remove` - для фильтрации доступных символов
- `str` - для конкатенации строк
- `concat` - для объединения списков
- `last` - для получения последнего символа

### Ограничения реализации

- Не используется рекурсия
- Не используются генераторы
- Не используются продвинутые функции типа `flatten`
- Используются только базовые операции со списками

## Запуск

### Запуск примеров

```bash
lein run
```

### Запуск тестов

```bash
lein test
```

### Интерактивная сессия REPL

```bash
lein repl
```

Затем в REPL:

```clojure
(require '[task-c1.core :refer :all])
(generate-strings ["a" "b" "c"] 2)
```

## Тесты

Проект включает набор тестов, проверяющих:

- Базовую функциональность (пример из задания)
- Генерацию строк длины 1
- Генерацию строк длины 3
- Работу с алфавитом из 2 символов
- Отсутствие повторяющихся подряд символов
- Граничные случаи (пустой алфавит, N=0, отрицательное N)

## Математическое обоснование

Для алфавита размера `k` и длины строки `n`:

- Количество возможных строк: `k * (k-1)^(n-1)`
  - Первый символ: `k` вариантов
  - Каждый последующий символ: `(k-1)` вариантов (исключая предыдущий)

Пример: для алфавита `["a" "b" "c"]` (k=3) и n=2:
- Количество: `3 * (3-1)^(2-1) = 3 * 2 = 6` строк

## Особенности реализации

1. **Итеративный подход**: использование `reduce` вместо рекурсии
2. **Функциональный стиль**: использование `map`, `filter`, `remove`
3. **Эффективность**: построение результата за один проход
4. **Читаемость**: понятная структура кода с комментариями

