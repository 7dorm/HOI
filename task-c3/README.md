# Task C3: Параллельный filter с использованием futures

## Описание

Реализация параллельного варианта функции `filter` на Clojure с использованием futures. Каждый future обрабатывает блок элементов, а не отдельный элемент. Реализация поддерживает как конечные, так и бесконечные входные последовательности, сохраняя ленивость (laziness) и улучшая производительность за счет параллелизма.

## Требования

- Clojure 1.11+
- Leiningen (для сборки и тестирования)

## Структура проекта

```
task-c3/
├── src/
│   └── task_c3/
│       └── core.clj          # Основная реализация
├── test/
│   └── task_c3/
│       └── core_test.clj     # Unit-тесты
├── project.clj               # Конфигурация Leiningen
└── README.md                 # Документация
```

## Основные функции

### `pfilter`

Параллельный вариант `filter`, обрабатывающий элементы блоками.

```clojure
(pfilter pred coll)
(pfilter pred coll chunk-size)
```

**Параметры:**
- `pred` - предикат для фильтрации
- `coll` - входная последовательность (может быть конечной или бесконечной)
- `chunk-size` - размер блока для параллельной обработки (по умолчанию 1000)

**Возвращает:** ленивую последовательность отфильтрованных элементов

**Примеры:**
```clojure
;; Фильтрация конечной последовательности
(pfilter even? (range 100))
=> (0 2 4 6 8 10 ...)

;; Фильтрация бесконечной последовательности
(take 10 (pfilter #(zero? (mod % 7)) (range)))
=> (0 7 14 21 28 35 42 49 56 63)

;; С указанием размера блока
(pfilter odd? [1 2 3 4 5 6 7 8 9 10] 3)
=> (1 3 5 7 9)
```

### `pfilter-optimized`

Оптимизированная версия с предварительной загрузкой блоков.

```clojure
(pfilter-optimized pred coll)
(pfilter-optimized pred coll chunk-size)
(pfilter-optimized pred coll chunk-size prefetch)
```

**Параметры:**
- `pred` - предикат для фильтрации
- `coll` - входная последовательность
- `chunk-size` - размер блока (по умолчанию 1000)
- `prefetch` - количество блоков для предварительной загрузки (по умолчанию 2)

Эта версия предварительно загружает несколько блоков параллельно для лучшей производительности.

### `benchmark-filter`

Сравнивает производительность стандартного и параллельного filter.

```clojure
(benchmark-filter pred coll)
(benchmark-filter pred coll chunk-size)
```

Выводит время выполнения для каждого варианта и демонстрирует эффективность параллелизма.

## Алгоритм

### Принцип работы

1. **Разбиение на блоки**: Входная последовательность разбивается на блоки заданного размера
2. **Параллельная обработка**: Каждый блок обрабатывается в отдельном future
3. **Ленивое объединение**: Результаты блоков объединяются лениво с использованием `lazy-seq` и `lazy-cat`
4. **По требованию**: Блоки обрабатываются только по мере необходимости

### Сохранение ленивости

Реализация использует `lazy-seq` и `lazy-cat` для сохранения ленивости:
- Блоки не обрабатываются заранее
- Futures создаются только при необходимости
- Результаты вычисляются по требованию

### Параллелизм

- Каждый блок обрабатывается в отдельном future
- Несколько блоков могут обрабатываться параллельно
- Оптимизированная версия предзагружает несколько блоков

## Примеры использования

### Базовые примеры

```clojure
(require '[task-c3.core :refer :all])

;; Фильтрация конечной последовательности
(pfilter even? (range 100))
=> (0 2 4 6 8 10 12 14 16 18 ...)

;; Фильтрация бесконечной последовательности
(take 20 (pfilter #(zero? (mod % 3)) (range)))
=> (0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51)

;; Сложный предикат
(pfilter #(and (even? %) (> % 10)) (range 100))
=> (12 14 16 18 20 22 24 ...)
```

### Сравнение производительности

```clojure
;; Запуск бенчмарка
(benchmark-filter even? (range 100000) 5000)

;; Вывод:
;; === Сравнение производительности filter ===
;; Размер входной последовательности: 100000
;; Размер блока для параллельного filter: 5000
;;
;; Стандартный filter:
;;   Время выполнения: 45 мс
;;   Первые 10 элементов: (0 2 4 6 8 10 12 14 16 18)
;;
;; Параллельный filter:
;;   Время выполнения: 28 мс
;;   Первые 10 элементов: (0 2 4 6 8 10 12 14 16 18)
```

### Работа с бесконечными последовательностями

```clojure
;; Бесконечная последовательность простых чисел (пример)
(def primes (pfilter 
              (fn [n] 
                (not-any? #(zero? (mod n %)) 
                          (take-while #(<= (* % %) n) (range 2 n))))
              (iterate inc 2)))

(take 10 primes)
=> (2 3 5 7 11 13 17 19 23 29)
```

## Запуск

### Запуск примеров

```bash
lein run
```

### Запуск тестов

```bash
lein test
```

### Интерактивная сессия REPL

```bash
lein repl
```

Затем в REPL:

```clojure
(require '[task-c3.core :refer :all])
(pfilter even? (range 100))
```

## Тесты

Проект включает comprehensive набор unit-тестов, покрывающих:

- ✅ Базовую функциональность
- ✅ Работу с пустыми коллекциями
- ✅ Работу с бесконечными последовательностями
- ✅ Сохранение ленивости
- ✅ Разные размеры блоков
- ✅ Сложные предикаты
- ✅ Сохранение порядка элементов
- ✅ Обработку различных типов данных
- ✅ Эквивалентность результатов стандартному filter
- ✅ Производительность

## Производительность

### Когда параллелизм эффективен

Параллельный filter наиболее эффективен когда:
1. **Тяжелый предикат**: Предикат выполняет сложные вычисления
2. **Большие коллекции**: Большое количество элементов для обработки
3. **Многопроцессорная система**: Доступно несколько ядер процессора

### Оптимизация размера блока

- **Маленький блок** (100-500): Больше overhead на создание futures, но лучше для интерактивных приложений
- **Средний блок** (1000-5000): Баланс между overhead и параллелизмом (рекомендуется)
- **Большой блок** (10000+): Меньше overhead, но меньше параллелизма

### Примеры производительности

Для тяжелого предиката (с задержкой):
- Стандартный filter: ~1000 мс
- Параллельный filter: ~250 мс (4x ускорение на 4 ядрах)

Для легкого предиката:
- Стандартный filter: ~10 мс
- Параллельный filter: ~15 мс (overhead может перевесить выгоду)

## Особенности реализации

1. **Ленивость**: Использование `lazy-seq` и `lazy-cat` обеспечивает ленивое вычисление
2. **Параллелизм**: Futures обрабатывают блоки параллельно
3. **Гибкость**: Поддержка как конечных, так и бесконечных последовательностей
4. **Эффективность**: Оптимизированная версия с предзагрузкой блоков

## Ограничения

1. **Overhead**: Для очень маленьких коллекций overhead может перевесить выгоду
2. **Память**: Предзагрузка блоков требует дополнительной памяти
3. **Порядок**: Порядок элементов сохраняется, но параллелизм может быть ограничен

## Математическое обоснование

Для коллекции размера `n` и блока размера `k`:
- Количество блоков: `⌈n/k⌉`
- Параллелизм: до `⌈n/k⌉` блоков могут обрабатываться параллельно
- Ускорение: теоретически до `min(⌈n/k⌉, количество_ядер)` раз

## Литература

- [Clojure Futures](https://clojure.org/reference/other_functions#futures)
- [Lazy Sequences в Clojure](https://clojure.org/reference/sequences)
- [Параллельное программирование в Clojure](https://clojure.org/reference/parallelism)

