# Task C2: Бесконечная последовательность простых чисел

## Описание

Реализация бесконечной последовательности простых чисел на Clojure с использованием алгоритма Решета Эратосфена с бесконечным верхним пределом.

## Требования

- Clojure 1.11+
- Leiningen (для сборки и тестирования)

## Структура проекта

```
task-c2/
├── src/
│   └── task_c2/
│       └── core.clj          # Основная реализация
├── test/
│   └── task_c2/
│       └── core_test.clj     # Unit-тесты
├── project.clj               # Конфигурация Leiningen
└── README.md                  # Документация
```

## Алгоритм Решета Эратосфена

Решето Эратосфена — это древний алгоритм для нахождения всех простых чисел до заданного предела. В данной реализации алгоритм адаптирован для работы с бесконечной последовательностью чисел.

### Принцип работы

1. Начинаем с последовательности всех натуральных чисел начиная с 2
2. Берем первое число из последовательности — оно простое
3. Удаляем из последовательности все числа, кратные этому простому числу
4. Рекурсивно применяем тот же процесс к оставшейся последовательности

### Реализация

Алгоритм реализован с использованием ленивых последовательностей Clojure (`lazy-seq`), что позволяет создавать бесконечную последовательность простых чисел без необходимости заранее знать верхний предел.

## Основные функции

### `primes`

Бесконечная последовательность простых чисел, начиная с 2.

```clojure
(take 10 primes)
=> (2 3 5 7 11 13 17 19 23 29)

(nth primes 99)
=> 541
```

### `sieve`

Вспомогательная функция, реализующая алгоритм Решета Эратосфена.

```clojure
(sieve (iterate inc 2))
=> (2 3 5 7 11 13 17 19 23 29 ...)
```

### `prime?`

Проверяет, является ли число простым.

```clojure
(prime? 7)
=> true

(prime? 10)
=> false
```

### `nth-prime`

Возвращает n-е простое число (нумерация с 0).

```clojure
(nth-prime 0)
=> 2

(nth-prime 99)
=> 541
```

### `primes-up-to`

Возвращает все простые числа до указанного предела (включительно).

```clojure
(primes-up-to 20)
=> (2 3 5 7 11 13 17 19)
```

## Примеры использования

### Базовые примеры

```clojure
(require '[task-c2.core :refer :all])

;; Первые 20 простых чисел
(take 20 primes)
=> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71)

;; 100-е простое число
(nth-prime 99)
=> 541

;; Простые числа до 50
(primes-up-to 50)
=> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)

;; Проверка на простоту
(prime? 17)
=> true

(prime? 25)
=> false
```

### Работа с бесконечной последовательностью

```clojure
;; Можно взять любое количество простых чисел
(take 100 primes)
(take 1000 primes)

;; Можно получить простое число по индексу
(nth primes 0)   ; => 2
(nth primes 999)  ; => 7919

;; Можно фильтровать последовательность
(take-while #(< % 100) primes)
=> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)
```

## Запуск

### Запуск примеров

```bash
lein run
```

### Запуск тестов

```bash
lein test
```

### Интерактивная сессия REPL

```bash
lein repl
```

Затем в REPL:

```clojure
(require '[task-c2.core :refer :all])
(take 10 primes)
```

## Тесты

Проект включает comprehensive набор unit-тестов, покрывающих:

- ✅ Базовую функциональность последовательности
- ✅ Первые несколько простых чисел
- ✅ Отсутствие дубликатов в последовательности
- ✅ Сортировку по возрастанию
- ✅ Получение n-го простого числа
- ✅ Функцию `primes-up-to`
- ✅ Проверку на простоту (простые числа)
- ✅ Проверку на простоту (составные числа)
- ✅ Бесконечность последовательности
- ✅ Ленивость последовательности
- ✅ Правильность алгоритма Решета Эратосфена
- ✅ Граничные случаи
- ✅ Производительность для больших индексов

## Особенности реализации

1. **Ленивые последовательности**: Использование `lazy-seq` позволяет создавать бесконечную последовательность без предварительного вычисления всех элементов.

2. **Эффективность**: Алгоритм эффективно фильтрует составные числа по мере их появления.

3. **Функциональный стиль**: Реализация следует функциональному программированию Clojure.

4. **Бесконечность**: Последовательность действительно бесконечна — можно получить любое количество простых чисел.

## Математическое обоснование

Решето Эратосфена работает следующим образом:

1. Начинаем со списка всех натуральных чисел начиная с 2
2. Первое число (2) простое — добавляем его в результат
3. Удаляем все числа, кратные 2 (4, 6, 8, ...)
4. Следующее число (3) простое — добавляем его в результат
5. Удаляем все числа, кратные 3 (6, 9, 12, ...)
6. И так далее...

В реализации с ленивыми последовательностями мы не удаляем числа физически, а фильтруем их по требованию, что позволяет работать с бесконечной последовательностью.

## Производительность

Алгоритм имеет временную сложность O(n log log n) для нахождения всех простых чисел до n. Для бесконечной последовательности элементы вычисляются по требованию, что делает реализацию эффективной для работы с большими индексами.

## Литература

- [Решето Эратосфена на Wikipedia](https://ru.wikipedia.org/wiki/Решето_Эратосфена)
- [Lazy Sequences в Clojure](https://clojure.org/reference/sequences)

